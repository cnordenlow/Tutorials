[
["r.html", "1 R 1.1 Create template tables 1.2 Import &amp; Export 1.3 Tidy &amp; Transform 1.4 Working with strings and characters 1.5 Visualize 1.6 Misc 1.7 R Markdown 1.8 Web Scraping 1.9 Useful functions / expressions", " 1 R 1.1 Create template tables 1.1.1 Template tables Create table with random dates between two dates. Use max date and create a table with dates until this date. #https://www.cyclismo.org/tutorial/R/basicOps.html#basic-operations library(dplyr) df &lt;- tibble( date = sample(seq(as.Date(&#39;2020/06/01&#39;), as.Date(&#39;2025/01/01&#39;), by=&quot;day&quot;), 20) ) df2 &lt;-tibble( date = seq.Date(Sys.Date(), max(as.Date(df$date)), by = &quot;day&quot;) ) Create new column with random number library(tidyverse) df &lt;- data.frame(Amount = 1:10) df %&gt;% rowwise %&gt;% mutate(newColumn = sample(1:5, 1)) #It´s often neccessary to ungroup rowwise. df &lt;- as.data.frame(df) Create table with a combination of fixed and random numbers library(tidyverse) df &lt;- tibble( value = seq(10,90,1), rand = seq(10,90,1) +runif(81, min=-10, max=15) ) **Create a list and bind together, only 1 column* libary(dplyr) lst &lt;- list(cars, cars) lst &lt;- bind_rows(lst) lst %&gt;% select(2) #Bind together list, include the index number / name. Use data.table library(data.table) lst &lt;- list(cars, cars) lst &lt;- rbindlist(lst, idcol = TRUE) 1.1.2 Creating list-columns library(tidyverse) library(purrr) library(gapminder) #List columns #data.frame treats a list as a list of columns data.frame(x = list(1:3, 3:5)) #Use of I can prevent this but dosen´t look good. data.frame( x = I(list(1:3, 3:5)), y = c(&quot;1,2&quot;,&quot;3,4,5&quot;) ) #Tibble can handle it tibble( x = list(1:3, 3:5), y = c(&quot;1,2&quot;, &quot;3,4,5&quot;) ) #Even easier with tribble tribble( ~x, ~y, 1:3, &quot;1,2&quot;, 3:5, &quot;3,4,5&quot; ) #nest() creates a nested data frame with a list-column of data frames. gapminder %&gt;% group_by(country, continent)%&gt;% nest() #from vectorized functions df &lt;- tribble( ~x1, &quot;a,b,c&quot;, &quot;d,e,f,g&quot; ) df %&gt;% mutate(x2 = stringr::str_split(x1, &quot;,&quot;))%&gt;% unnest() #using Purrr sim &lt;- tribble( ~f, ~params, &quot;runif&quot;, list(min = -1, max=-1), &quot;rnorm&quot;, list(sd = 5), &quot;rpois&quot;, list(lambda=10) ) sim %&gt;% mutate(sims = invoke_map(f, params, n = 10)) #from multivalued summaries, you need to wrap it in a list for being able to summarise. mtcars %&gt;% group_by(cyl)%&gt;% summarize(q=list(quantile(mpg))) probs &lt;- c(0.01, 0.25,0.5,0.75,0.99) mtcars %&gt;% group_by(cyl)%&gt;% summarize(p = list(probs), q=list(quantile(mpg))) #from a named list x &lt;- list( a = 1:5, b = 3:4, c = 5:6 ) df &lt;- enframe(x) df df %&gt;% mutate(smry = map2_chr( name, value, ~ stringr::str_c(.x, &quot;: &quot;, .y[1]) )) 1.2 Import &amp; Export 1.2.1 Import Import fast using httpcashe Improving efficiency in importing get_data &lt;- function(url) { httpcache::GET(url) %&gt;% httr::content() } url_jobless_claims=&quot;https://oui.doleta.gov/unemploy/csv/ar539.csv&quot; data_jobless_claims &lt;- get_data(url_jobless_claims) Import all files in a folder Import all files in a folder. In the example below files are named “2020-05-05 Saldo”. Import and create a table where the date of the filename is used in a column. Change name for column 1 and 2. Map has similiar functionality to lapply. When you add _dfr it will generate data.frames and that these is merged. parse_date &lt;- function(x) as.Date(gsub( &quot;.*(\\\\d{4}-\\\\d{2}-\\\\d{2}).*&quot;, &quot;\\\\1&quot;, x)) dir_loc &lt;- &#39;...RX-filer\\\\Saldo&#39; rix_saldo &lt;- dir(dir_loc, full.names = T) %&gt;% map_dfr(~{ read.csv2(.x, skip = 1, header = F) %&gt;% mutate(date = as.Date(parse_date(basename(.x)))) }) colnames(rix_saldo)[colnames(rix_saldo) == &#39;V1&#39;] &lt;- &#39;Participant&#39; colnames(rix_saldo)[colnames(rix_saldo) == &#39;V2&#39;] &lt;- &#39;Saldo&#39; Import all files in a folder with conditions of name Use pattern to set the conditions which files that should be imported. For example, those who ends with “Saldo.csv” as below. Regexp (see http://jkorpela.fi/perl/regexp.html) is used in pattern. For example, you need to use \\. for the dot. Also, ^ can be used to determine the beginning of a string while $ is used to set the end. pattern = \"^.Saldo\\.csv$\"* parse_date &lt;- function(x) as.Date(gsub( &quot;.*(\\\\d{4}-\\\\d{2}-\\\\d{2}).*&quot;, &quot;\\\\1&quot;, x)) dir_loc &lt;- &#39;...RX-filer\\\\Saldo&#39; rix_saldo &lt;- dir(dir_loc, full.names = T, pattern = &quot;^.*Saldo\\\\.csv$&quot;) %&gt;% map_dfr(~{ read.csv2(.x, skip = 1, header = F) %&gt;% mutate(date = as.Date(parse_date(basename(.x)))) }) colnames(rix_saldo)[colnames(rix_saldo) == &#39;V1&#39;] &lt;- &#39;Participant&#39; colnames(rix_saldo)[colnames(rix_saldo) == &#39;V2&#39;] &lt;- &#39;Saldo&#39; Import all excel files in a folder with condition of name #Import a .xlsm files, one particular sheet. dir_loc &lt;- &#39;...\\\\Operations\\\\History_bokningssnurra&#39; dir &lt;-dir(dir_loc, full.names = T, pattern =&quot;.xlsm&quot;) rawData &lt;- map_dfr(dir, read_xlsx, sheet = &quot;indata_AUPD&quot;, col_names = TRUE, col_types = &#39;text&#39;) Import excel from web Import excel from web by downloading it temp library(readxl) url_data_gdp &lt;- (&quot;https://www.bea.gov/system/files/2020-04/qgdpstate0420.xlsx&quot;) download.file(url=url_data_gdp, destfile=&quot;localcopy.xlsx&quot;, mode=&quot;wb&quot;) #Table 1: Percent Change in Real Gross Domestic Product (GDP) by State and state table1 &lt;- read_excel(&#39;localcopy.xlsx&#39;, sheet = 1, skip =4, col_names = FALSE) 1.2.2 Export Export to txt file write.table(table_for_report, &quot;...\\\\Operations\\\\LikvProg\\\\likvprog_history.txt&quot;, sep=&quot;\\t&quot;) Export to csv file #Using both write.csv2 or write.table library(data.table) #Write csv2. No row.names, na = &quot;&quot; and quote (&quot;&quot;) mark as false write.csv2(total_purchases_commercial_papers, &quot;.....R_tables\\\\Output_data\\\\webpage_purchases\\\\Total_purchases_commercial_papers.csv&quot;,row.names=FALSE,na = &quot;&quot;, quote = FALSE) #Write.table. No row.names, na = &quot;&quot; and quote (&quot;&quot;) mark as false write.table(total_purchases_commercial_papers,file=&quot;...\\\\Total_purchases_commercial_papers3.csv&quot;,row.names=FALSE,sep=&quot;;&quot;,dec = &quot; &quot;,quote = FALSE) Get table to paste into excel write.excel &lt;- function(x,row.names=FALSE,col.names=TRUE,...) { write.table(df,&quot;clipboard&quot;,sep=&quot;\\t&quot;,row.names=row.names,col.names=col.names,...) } write.excel(my.df) 1.3 Tidy &amp; Transform 1.3.1 Cleaning Cleaning some data Gather, Spread, Separate, Unite library(tidyr) #Create a messy dataset messy &lt;- data.frame( country = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), q1_2017 = c(0.03, 0.05, 0.01), q2_2017 = c(0.05, 0.07, 0.02), q3_2017 = c(0.04, 0.05, 0.01), q4_2017 = c(0.03, 0.02, 0.04)) messy #Reshape the data. in this function we create two new variables instead of the one in the original dataset. tidier &lt;- messy%&gt;% gather(quarter, growth, q1_2017:q4_2017) tidier #Spread #the spread function does the opposite of gather. #Reshape the tidier dataset back to messy. messy_1 &lt;- tidier %&gt;% spread(quarter, growth) messy_1 #Separate #Separate splits a column into two according to a separator. This function is helpful in some situations where the variable is a date, i.e. separate year and month. separate_tidier &lt;- tidier %&gt;% separate(quarter, c(&quot;Qrt&quot;, &quot;year&quot;), sep =&quot;_&quot;) head(separate_tidier) #Unite #Unite concatenates two columns into one. unit_tidier &lt;- separate_tidier%&gt;% unite(Quarter, Qrt, year, sep = &quot;_&quot;) head(unit_tidier) 1.3.2 Expand Expand table One example with expanding to all alternatives. Another to fill in gaps. library(tidyverse) library(dplyr) ##Expand all alternatives a &lt;- c(1:10) b &lt;- c(1:10) c &lt;- c(1:10) df &lt;- tibble(a,b,c) all_combinations &lt;- expand(df, a,b,c) #Expand by missing Date df &lt;- tibble( year = c(2010, 2010, 2010, 2010, 2012, 2012, 2012), qtr = c( 1, 2, 3, 4, 1, 2, 3), return = rnorm(7) ) df %&gt;% expand(year, qtr) df %&gt;% expand(year = 2010:2012, qtr) df %&gt;% complete(year = full_seq(year, 1), qtr) 1.3.3 Join and Merge Join tables Different ways to join tables. library(dplyr) df_primary &lt;- tribble( ~ID,~y, &quot;A&quot;, 5, &quot;B&quot;, 5, &quot;C&quot;, 8, &quot;D&quot;, 0, &quot;E&quot;, 9) df_secondary &lt;- tribble( ~ID,~y, &quot;A&quot;, 30, &quot;B&quot;, 21, &quot;C&quot;, 22, &quot;D&quot;, 25, &quot;F&quot;, 29) #Most common way to merge two datasets is to uset the left_join() function. left_join_ &lt;- left_join(df_primary, df_secondary, by =&#39;ID&#39;) #The right_join works like the left one. right_join_ &lt;- right_join(df_primary, df_secondary, by = &#39;ID&#39;) #When we are sure that two datasets won´t match, we can consider to return only rows existing in both datasets. #This is legit when we need a clean dataset or when we dont want to impute missing values with the mean or median. inner_join_ &lt;- inner_join(df_primary, df_secondary, by =&#39;ID&#39;) # Full_join keeps all observations and replace missing values with NA. full_join_ &lt;- full_join(df_primary, df_secondary, by = &#39;ID&#39;) Join tables on multiple conditions Join Tables on multiple conditions library(dplyr) df_primary &lt;- tribble( ~ID, ~year, ~items, &quot;A&quot;, 2015,3, &quot;A&quot;, 2016,7, &quot;A&quot;, 2017,6, &quot;B&quot;, 2015,4, &quot;B&quot;, 2016,8, &quot;B&quot;, 2017,7, &quot;C&quot;, 2015,4, &quot;C&quot;, 2016,6, &quot;C&quot;, 2017,6) df_secondary &lt;- tribble( ~ID, ~year, ~prices, &quot;A&quot;, 2015,9, &quot;A&quot;, 2016,8, &quot;A&quot;, 2017,12, &quot;B&quot;, 2015,13, &quot;B&quot;, 2016,14, &quot;B&quot;, 2017,6, &quot;C&quot;, 2015,15, &quot;C&quot;, 2016,15, &quot;C&quot;, 2017,13) left_join(df_primary, df_secondary, by = c(&#39;ID&#39;, &#39;year&#39;)) Merge Data Frames Merge Data Frames in R: Full and partial match producers &lt;- data.frame( surname = c(&quot;Spielberg&quot;,&quot;Scorsese&quot;,&quot;Hitchcock&quot;,&quot;Tarantino&quot;,&quot;Polanski&quot;), nationality = c(&quot;US&quot;,&quot;US&quot;,&quot;UK&quot;,&quot;US&quot;,&quot;Poland&quot;), stringsAsFactors=FALSE) # Create destination dataframe movies &lt;- data.frame( surname = c(&quot;Spielberg&quot;, &quot;Scorsese&quot;, &quot;Hitchcock&quot;, &quot;Hitchcock&quot;, &quot;Spielberg&quot;, &quot;Tarantino&quot;, &quot;Polanski&quot;), title = c(&quot;Super 8&quot;, &quot;Taxi Driver&quot;, &quot;Psycho&quot;, &quot;North by Northwest&quot;, &quot;Catch Me If You Can&quot;, &quot;Reservoir Dogs&quot;,&quot;Chinatown&quot;), stringsAsFactors=FALSE) m1 &lt;- merge(producers, movies, by.x = &quot;surname&quot;) m1 # Change name of ` movies ` dataframe colnames(movies)[colnames(movies) == &#39;surname&#39;] &lt;- &#39;name&#39; # Merge with different key value m2 &lt;- merge(producers, movies, by.x = &quot;surname&quot;, by.y = &quot;name&quot;) ##Partial match # Create a new producer add_producer &lt;- c(&#39;Lucas&#39;, &#39;US&#39;) # Append it to the ` producer` dataframe producers &lt;- rbind(producers, add_producer) # Use a partial merge m3 &lt;-merge(producers, movies, by.x = &quot;surname&quot;, by.y = &quot;name&quot;, all.x = TRUE) m3 1.3.4 Transforming data with Apply etc apply(), lapply(), sapply(), tapply() apply() library(dplyr) m1 &lt;- matrix(c&lt;-(1:10), nrow=5,ncol=6) m1 #Sums columns a_m1 &lt;- apply(m1,2,sum) a_m1 #Sums rows a_m1 &lt;- apply(m1,1,sum) a_m1 lapply() library(dplyr) movies &lt;- c(&quot;spyderman&quot;, &quot;batman&quot;, &quot;vertigo&quot;, &quot;chinatown&quot;) movies_lower &lt;- lapply(movies, tolower) str(movies_lower) #if we like to convert the list into a vector we can use unlist() movies_lower &lt;- unlist(lapply(movies, tolower)) str(movies_lower) sapply() #sapply() function does the same jobs as lapply() function but returns a vectorÄ library(dplyr) dt &lt;- cars lmn_cars &lt;- lapply(dt, min) smn_cars &lt;- sapply(dt,min) lmn_cars smn_cars lmxcars &lt;- lapply(dt,max) smxcars &lt;- sapply(dt,max) lmxcars smxcars #lets create a function names avg to compute the average of the minimun and maximun of the vector. avg &lt;- function(x){ (min(x) + max(x))/2 } fcars &lt;- sapply(dt, avg) fcars #sapply() function is more efficient than lapply() in the output returned because sapply() store values directly into a vector. #it is possible to use lapply or sapply interchangeable to slice a data frame. #lets compute a function that takes a vector of numerical values and returns a vector that only contains the values that are strictly above the average. below_ave &lt;- function(x){ ave &lt;- mean(x) return(x[x&gt;ave]) } dt_s &lt;- sapply(dt, below_ave) dt_l &lt;- lapply(dt, below_ave) identical(dt_s, dt_l) tapply() #The function tapply() computes a measure (mean, median, min, max) or a function for each factor variable in a vector library(dplyr) data(iris) tapply(iris$Sepal.Width, iris$Species, median) 1.3.5 Tally-function Tally() Tally is a useful wrapper for summarise with grouping conditions. In the example below we have a data set with countries. For US, there are no aggregate number, so we need to summarize each state. library(tidyr) library(dplyr) df &lt;- tibble::tribble( ~country, ~state, ~t1, ~t2, &quot;SE&quot;, NA, 1,2, &quot;US&quot;, &quot;A&quot;, 10,20, &quot;US&quot;, &quot;B&quot;, 11,21, ) df%&gt;% tidyr::gather(date, value, -country, -state)%&gt;% group_by(country, date) %&gt;% tally(value) ## Iteration with purrr Purrr: map functions map() makes a list map_lgl() makes a logical vector map_int() makes an integer vector map_dbl() makes a double vector map_chr() makes a character vector #calculate mean library(tidyverse) df &lt;- tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10) ) map_dbl(df, mean) z &lt;- list(x = 1:3, y = 4:5) map_int(z, length) #using splits. splits mtcars in three pieces and fits the same linear model to each piece. models &lt;- mtcars %&gt;% split(.$cyl) %&gt;% map(~lm(mpg ~ wt, data =.)) #. refers to the current list element, as i referred to the current index in the for loop. models %&gt;% map(summary) %&gt;% map_dbl(&quot;r.squared&quot;) #use an integer to select elements x &lt;- list(list(1,2,3), list(4,5,6), list(7,8,9)) x %&gt;% map_dbl(2) #Dealing with failure: Safely safe_log &lt;- safely(log) str(safe_log(10)) x &lt;- list(1,10,&quot;a&quot;) y &lt;- x %&gt;% map(safely(log)) str(y) #combine with transpose to get two lists, one with failure and one that works. y &lt;- y %&gt;% transpose() str(y) #work with the values that are ok or not ok. is_ok &lt;- y$error %&gt;%map_lgl(is_null) x[!is_ok] y$result[is_ok] %&gt;% flatten_dbl() #other useful verbs with purrr: possibly() and quietly() # possibly x &lt;- list(1,10,&quot;a&quot;) x %&gt;% map_dbl(possibly(log, NA_real_)) # quietly() x &lt;- list(1, -1) x %&gt;% map(quietly(log)) %&gt;%str() 1.3.6 Mapping over multiple arguments map2 ##Mapping over multiple arguments ## map2: iterates over two vectors parallel. #arguments that vary for each call come before the function, arguments that are the same for every call come after. mu &lt;- list(5,10,-3) sigma &lt;- list(1,5,10) map2(mu, sigma, rnorm, n=5) %&gt;% str() ## pmap(): takes a list of arguments n &lt;- lsit(1,3,5) args1 &lt;- list(n,mu,sigma) args1 %&gt;% pmap(rnorm) %&gt;% str() #good practise is to name the arguments. args2 &lt;- list(mean = mu, sd = sigma, n = n) args2 %&gt;% pmap(rnorm)%&gt;% str() #since the argments are the same length, it makes sense to store them in a data frame. params &lt;- tribble( ~mean, ~sd, ~n, 5, 1, 1, 10, 5, 3, -3, 10,5 ) params%&gt;% pmap(rnorm) #invoking different functions f &lt;- c(&quot;runif&quot;, &quot;rnorm&quot;, &quot;rpois&quot;) param &lt;- list( list(min = -1, max = 1), list(sd =5), list(lambda = 10) ) invoke_map(f, param, n= 5)%&gt;% str() Purrr pattern finders ## Keep elements of input where the predicate is true iris %&gt;% keep(is.factor) %&gt;% str() #discard elements iris %&gt;% discard(is.factor) %&gt;% str() #some determine if the predicate is true for any x &lt;- list(1:5, letters, list(10)) x %&gt;% some(is_character) #every determine if the predicate is true for all x %&gt;% every(is_vector) # detect() finds the first element where the predicate is true x &lt;- sample(10) x x %&gt;% detect(~ . &gt; 5) x %&gt;% detect_index(~ . &gt;5) #head_While #take elements from the start or end of a vector while a predicate is true. pos &lt;- function(x) x &gt;= 0 head_while(5:-5, pos) big &lt;- function(x) x &gt; 5 head_while(0:10, big) tail_while(0:10, big) #reduce and accumulate dfs &lt;- list( age = tibble(name = &quot;john&quot;, age = 30), sex = tibble(name = c(&quot;john&quot;, &quot;mary&quot;), sex = c(&quot;M&quot;, &quot;F&quot;)), trt = tibble(name = &quot;mary&quot;, treatment = &quot;A&quot;) ) dfs %&gt;% reduce(full_join) # find the intersection vs &lt;- list( c(1,3,5,6,10), c(1,2,3,6,7,8), c(1,2,3,4,5,6) ) vs %&gt;% reduce(intersect) #accumulate x &lt;- sample(10) x x %&gt;% accumulate(`+`) 1.4 Working with strings and characters Remove last n characters #Remove last n characters in a string df &lt;- tibble( program = c(rep(&quot;okv 20200528&quot;,10), rep(&quot;ftg 20200525&quot;,10)) ) df$program &lt;- substr(df$program,1,nchar(df$program)-9) 1.5 Visualize 1.5.1 Ggplots geom_line with geom_ribbon geom_line with geom_ribbon for pos / neg numbers library(ggplot2) df &lt;- tibble( value = seq(1,50,1), rand = seq(1,50,1) +runif(50, min=-10, max=15) )%&gt;% mutate(diff = rand - value) exposure_graph &lt;- ggplot(df, aes(x=value,y=rand)) + geom_ribbon(aes(ymin=pmin(df$diff,0), ymax=0), fill=&quot;red&quot;, col=&quot;black&quot;, alpha=0.5) + geom_ribbon(aes(ymin=0, ymax=pmax(df$diff,0)), fill=&quot;blue&quot;, col=&quot;black&quot;, alpha=0.5) + geom_line(aes(y=0)) 1.5.2 Different tables Create table with kableExtra Create table with different colors for pos / neg numbers library(tidyverse) library(kableExtra) df &lt;- tibble( type = c(&quot;gov_bond&quot;, &quot;ssa&quot;, &quot;ssa&quot;, &quot;gov_bond&quot;,&quot;ssa&quot;, &quot;ssa&quot;, &quot;gov_bond&quot;, &quot;gov_bond&quot;, &quot;gov_bond&quot;, &quot;ssa&quot;), maturity_bucket = as.integer(runif(10, min =1, max=6)), diff_bm = runif(10, min = -10, max = 10) ) sum_type &lt;- df %&gt;% group_by(type, maturity_bucket)%&gt;% summarise( diff_exposure = round(sum(diff_bm),1) ) ## Create table with green for positive, red for negative sum_table &lt;- sum_type%&gt;% mutate( diff_exposure = ifelse(diff_exposure &lt; 0, cell_spec(diff_exposure, &quot;html&quot;, color = &quot;red&quot;, bold = T), cell_spec(diff_exposure, &quot;html&quot;, color = &quot;green&quot;, italic = T)))%&gt;% kable(&quot;html&quot;, escape = F, format.args=list(big.mark=&quot; &quot;, scientific=F)) %&gt;% kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;), full_width = F, position= &quot;right&quot;, fixed_thead = T) sum_table 1.6 Misc 1.6.1 Moving average Create a moving average Example of creating a moving average for dates. library(tidyverse) library(dplyr) library(lubridate) library(slider) library(dplyr, warn.conflicts = FALSE) library(lubridate, warn.conflicts = FALSE) df &lt;- tibble( Date = seq.Date(Sys.Date()-19, Sys.Date(), by=&quot;day&quot;), indicator = c(rep(1,10),rep(2,10)), value = rnorm(20) ) df &lt;- arrange(df, Date) df %&gt;% group_by(indicator) %&gt;% mutate(MA_3m = slide_index_dbl(value, Date, mean, .before=lubridate::days(2), .after=0,.complete=T)) #Use before or after = Inf if you like to get the calculation based on all values before or after. 1.6.2 Number rows within group library(dplyr) mtcars %&gt;% group_by(cyl) %&gt;% mutate(num = 1:n()) 1.6.3 Date Formating Different ways to format dates Dates as.Date(&quot;2/15/1986&quot;, format = &quot;%m/%d/%Y&quot;) Formating date with use of gsub to adjust the the string. library(tidyverse) date_to_format = &quot;2016-10-17 UTC&quot; as.Date(gsub(&quot;\\\\D&quot;, &quot;&quot;, date_to_format), format = &quot;%Y%m%d&quot;) #or changing who table df &lt;- tibble( date_to_format = &quot;2016-10-17 UTC&quot; ) df &lt;- df %&gt;% mutate(date_to_format = as.Date(gsub(&quot;\\\\D&quot;, &quot;&quot;, date_to_format), format = &quot;%Y%m%d&quot;)) 1.6.4 Loops 1.6.4.1 For loop example Creates a non-linear function by using the polynomial of x between 1 and 4 and we store it in a list # # Create an empty list list &lt;- c() # Create a for statement to populate the list for (i in seq(1, 4, by=1)) { list[[i]] &lt;- i*i } print(list) For loop over a matrix A matrix has 2-dimension, rows and columns. To iterate over a matrix, we have to define two for loop, namely one for the rows and another for the column. # Create a matrix mat &lt;- matrix(data = seq(10, 20, by=1), nrow = 6, ncol =2) # Create the loop with r and c to iterate over the matrix for (r in 1:nrow(mat)) for (c in 1:ncol(mat)) print(paste(&quot;Row&quot;, r, &quot;and column&quot;,c, &quot;have values of&quot;, mat[r,c])) 1.6.4.2 For loop example Creates a non-linear function by using the polynomial of x between 1 and 4 and we store it in a list # # Create an empty list list &lt;- c() # Create a for statement to populate the list for (i in seq(1, 4, by=1)) { list[[i]] &lt;- i*i } print(list) 1.6.4.3 For loop and while loop #for loops df &lt;- tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10) ) #calculate median output &lt;- vector(&quot;double&quot;, ncol(df)) ###Allocate sufficient space, otherwise it could be slow. for (i in seq_along(df)){ ###Seq_along is better than sing 1:length(), becasue it can handle zero-length vector. output[[i]] &lt;- median(df[[i]]) } output #for loop: modifying an existing object df &lt;- tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10) ) rescale01 &lt;- function(x){ rng &lt;- range(x, na.rm = TRUE) (x - rng[1]) / rng[2] - rng[1] } for (i in seq_along(df)){ df[[i]] &lt;- rescale01(df[[1]]) } ## unknown output length means &lt;- c(0,1,2) output &lt;- double() for (i in seq_along(means)) { #not very efficient n &lt;- sample(100,1) output &lt;- c(output, rnorm(n, means[[i]])) } str(output) #better to save in a list and then combine out &lt;- vector(&quot;list&quot;, length(means)) for (i in seq_along(means)){ n &lt;- sample(100,1) out[[i]] &lt;- rnorm(n, means[[i]]) } str(out) str(unlist(out)) ##unlist a list #unknown sequence length. While loop. WHile loops only has two components, a condition and a body. #how many tries it takes to get three heads in a row. flip &lt;- function() sample(c(&quot;T&quot;, &quot;H&quot;), 1) flips &lt;- 0 nheads &lt;- 0 while (nheads &lt; 3) { if(flip() == &quot;H&quot;){ nheads &lt;- nheads + 1 } else { nheads &lt;- 0 } flips &lt;- flips + 1 } flips Function for Right and Left Functions for Right and Left. library(dplyr) right = function(text, num_char) { substr(text, nchar(text) - (num_char-1), nchar(text)) } left = function(text, num_char) { substr(text, 1, num_char) } df &lt;- tibble( Date = seq.Date(Sys.Date()-19, Sys.Date(), by=&quot;day&quot;), indicator = c(rep(1,10),rep(2,10)), value = rnorm(20) ) left(df$value, 3) right(df$Date, 3) Bloomberg API in R Blmrg API with package Rblpapi library(Rblpapi) con &lt;- blpConnect() #generic us10 &lt;- bdh(securities = &quot;USGG10YR Index&quot;, fields = &quot;PX_LAST&quot;, start.date = as.Date(&quot;2020-03-01&quot;)) #Isin us10 &lt;- bdh(securities = &quot;US912828ZQ64 Govt&quot;, fields = &quot;PX_LAST&quot;, start.date = as.Date(&quot;2020-03-01&quot;)) ##Multiple fields bonds &lt;- c(&quot;CA135087K601 Govt&quot;,&quot;CA563469UP83 Govt&quot;) fields &lt;- c(&quot;PX_LAST&quot;, &quot;YLD_YTM_MID&quot;, &quot;PX_DIRTY_MID&quot;, &quot;Issuer&quot;, &quot;SHORT_NAME&quot;, &quot;YRS_TO_MTY_ISSUE&quot;,&quot;YAS_ASW_SPREAD&quot;, &quot;CPN&quot;, &quot;AMT_OUTSTANDING&quot;, &quot;%_OF_TSY_HLD_IN_THE_FED_RES_SOMA&quot;, &quot;YLD_CHG_NET_1D&quot;, &quot;YLD_CHG_NET_1M&quot;, &quot;INTERVAL_Z_SCORE&quot;, &quot;MTY_YEARS_TDY&quot;, &quot;YLD_CHG_NET_5D&quot;) df &lt;- bdp(securities = bonds, fields = fields) df &lt;- tibble::rownames_to_column(df, &quot;isin_govt&quot;) 1.7 R Markdown 1.7.1 Render multiple reports Render multiple reports in different folders. In the example below one report is created for each stated currency. Params = list(currency) is the key. #Write in one R Script #Remove old file.remove(&quot;...xxx/report/Benchmark_R/Portfolio_report_GBP.html&quot;) file.remove(&quot;...xxx/report/Benchmark_R/Portfolio_report_AUD.html&quot;) file.remove(&quot;...xxx/report/Benchmark_R/Portfolio_report_EUR.html&quot;) purrr::map( c(&quot;AUD&quot;, &quot;EUR&quot;, &quot;GBP&quot;), ~ { res &lt;- rmarkdown::render(&quot;...xxx\\\\report\\\\Benchmark_R\\\\R code\\\\Markdown BM.Rmd&quot;, output_file = sprintf(&quot;...xxx\\\\report\\\\Benchmark_R\\\\Portfolio_report_%s.html&quot;, .x), params = list(currency = .x)) file.copy(res, sprintf(&quot;...xxx\\\\report\\\\Benchmark_R\\\\Old_reports\\\\Portfolio_report_%1$s_%2$s.html&quot;, .x, Sys.Date())) file.copy(res, sprintf(&quot;...xxx/report/Benchmark_R//Portfolio_report_%s.html&quot;, .x)) } ) #Markdown Report header --- #title: &quot;Portfolio and benchmark report&quot; output: html_document date: &quot;`r Sys.Date()`&quot; author: christoffer.nordenlow@outlook.com params: currency: &quot;EUR&quot; title: &quot;`r sprintf(&#39;Portfolio and benchmark report, %s&#39;, params$currency)`&quot; --- 1.8 Web Scraping 1.8.1 Scrape all sub page Scrape web page info and save in a table Scrape all different sub web pages under a base page. In the below example there a number of sub pages under the base bage. R is scraping all different URL under the main page. Info in the tables under the sub pages are saved in a table. You will need to have HTTP_PROXY/HTTPS_PROXY as environment variables. #https://cran.r-project.org/web/packages/rvest/rvest.pdf require(rvest) require(xml2) require(tidyverse) .base_url &lt;- &quot;https://www.riksbank.se&quot; doc &lt;- read_html(file.path(.base_url, &quot;sv/penningpolitik/penningpolitiska-instrument/kop-av-foretagscertifikat/special-terms-and-conditions/&quot;)) urls &lt;- doc %&gt;% html_nodes(&quot;a&quot;) %&gt;% html_attr(&quot;href&quot;) urls &lt;- urls[str_detect(urls, regex(&quot;.*/special-terms-and-conditions/.*bid-date.*$&quot;))] urls &lt;- file.path(.base_url, urls) names(urls) &lt;- basename(urls) doc_subpage &lt;- read_html(urls[[1]]) df &lt;- urls %&gt;% map_dfr(~{ doc_subpage %&gt;% html_node(&quot;table&quot;) %&gt;% html_table() %&gt;% rename(key=X1, value=X2) %&gt;% as_tibble() }, .id = &quot;url&quot;) #It is possible to filter which files should be imported. #map(...) %&gt;% filter(lubridate::year(date) == 2019) 1.8.2 Scrape PL table Scrape one table library(rvest) web_pl &lt;- read_html(&quot;https://www.foxsports.com/soccer/stats?competition=1&amp;season=20190&amp;category=standard&amp;sort=3&quot;) tbls &lt;- html_nodes(web_pl, &quot;table&quot;) head(tbls) pl_stats &lt;- web_pl %&gt;% html_nodes(&quot;table&quot;) %&gt;% # .[3:4] %&gt;% html_table(fill = TRUE)%&gt;% .[[1]] 1.8.3 Scrape all tables Scrape all tables, use one ##Web scrape US Data. Payroll #http://bradleyboehmke.github.io/2015/12/scraping-html-tables.html library(rvest) web_bls &lt;- read_html(&quot;http://www.bls.gov/web/empsit/cesbmart.htm&quot;) tbls &lt;- html_nodes(web_bls, &quot;table&quot;) #extract all table nodes that exist on the page. head(tbls) #To parse the HTML, we use html_table. In this example it creates table_bls &lt;- web_bls %&gt;% html_nodes(&quot;table&quot;) %&gt;% .[3:4] %&gt;% ##determines which tables. In this case, table 3 and 4. html_table(fill = TRUE) str(table_bls) #Extract table 2, non-farm head(table_bls[[2]], 4) # remove row 1 that includes part of the headings. Not neccessary here #table_bls[[2]] &lt;- table_bls[[2]][-1,] table_bls2 &lt;-table_bls[[2]] 1.8.4 Scrape title Scrape title library(rvest) lego_movie &lt;- read_html(&quot;http://www.imdb.com/title/tt1490017/&quot;) lego_movie %&gt;% html_node(xpath=&#39;//div[@class=&quot;originalTitle&quot;]&#39;) %&gt;% html_text() 1.9 Useful functions / expressions 1.9.1 Sub / Gsub Replace the first occurence of a pattern with a sub or replace all occurrences with gsub. Gsub() replaces all matches of a string. x &lt;- &quot;Old City&quot; gsub(&quot;Old&quot;, &quot;New&quot;, x) #case insensitive gsub(&quot;old&quot;, &quot;New&quot;, x, ignore.case=T) #Vector replacement y &lt;- c(&quot;Stockholm City&quot;, &quot;Uppsala City&quot;, &quot;Malmö&quot;) gsub(&quot; City&quot;,&quot;&quot;,y) ### rnorm Generate number from a normal distribution. rnorm(4) #&gt; [1] -2.3308287 -0.9073857 -0.7638332 -0.2193786 # Use a different mean and standard deviation rnorm(4, mean=50, sd=10) #&gt; [1] 59.20927 40.12440 44.58840 41.97056 # To check that the distribution looks right, make a histogram of the numbers x &lt;- rnorm(400, mean=50, sd=10) hist(x) 1.9.2 slice Example: way to take out a single row. library(dplyr) mtcars select_row = 1 df &lt;- arrange(mtcars, mpg) df2 &lt;- df %&gt;% slice(which(row_number() == select_row)) 1.9.3 unique Example: get all unique values in a column library(dplyr) library(data.table) df &lt;- mtcars unique(df$cyl, incomparables = FALSE) 1.9.4 Map (purrr) Apply a function to each element of as list or vector. https://purrr.tidyverse.org/reference/map.html # map_dfr # apply a function to each element library(tidyverse) leading_indicators &lt;- c( &quot;INJCJC Index&quot;, &quot;INJCJC4 Index&quot;, &quot;INJCSP Index&quot;, &quot;RSTAMOM Index&quot;, &quot;SAARTOTL Index&quot;, &quot;USHBTRAF Index&quot;, &quot;DGNOCHNG Index&quot;, &quot;DGNOYOY Index&quot;, &quot;LEI CHNG Index&quot; ) get_data &lt;- function(indicator) { tibble(ind = indicator, data = 1) } leading_indicators %&gt;% map_dfr(get_data) "]
]
