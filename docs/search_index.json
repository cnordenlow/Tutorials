[
["sql.html", "4 SQL 4.1 Basic 4.2 SQL databases and R", " 4 SQL Operator Description Example abs() Calculates the absolute value abs(x) coalesce() Converts a possible null value into a default coalesce(z,y) instr() Checks if a text string contains another text string instr(‘HTX’, ‘TX’) length() Provides the number of characters in a string length(‘Test’) trim() Removes extraneous on both sides of a string trim(’ Test ’) ltrim() Removes extraneous on the left side of a string ltrim(’ Test’) rtrim() Removes extraneous on the right side of a string rtrim(‘Test’) random() Returns a random number random() round() Rounds a decimal to specified number round(100.101, 2) replace() Replaces a substring of text in a string replace(‘Test df’, ’ df’, ’’) substr() Extracts a range of characters from a string with their num position substr(‘Test’, 2,3) lower() Turns all letters in a string to lowercase lower(‘Test’) upper() Turns all letters in a string to uppercase upper(‘Test’) 4.1 Basic https://www.w3schools.com/sql/default.asp ‘Getting started with SQL’ using SQLite. https://github.com/thomasnield/oreilly_getting_started_with_sql 4.1.1 SELECT SELECT * FROM CUSTOMER; SELECT CUSTOMER_ID, NAME FROM CUSTOMER; # Generate a calculated column SELECT PRODUCT_ID, DESCRIPTION, PRICE AS UNTAXED_PRICE, round(PRICE * 1.07,2) AS TAXED_PRICE FROM PRODUCT; # Text concatenation. Concatenation works with any data type. SELECT NAME, CITY || &#39;, &#39; || STATE AS LOCATION FROM CUSTOMER; 4.1.1.1 WHERE SELECT * FROM STATION_DATA WHERE year = 2010; #Use != or &lt;&gt; to get everything but 2010 SELECT * FROM STATION_DATA WHERE year != 2010; #AND, OR, IN statements SELECT * FROM STATION_DATA WHERE year &gt;= 2005 AND year &lt;= 2010; #in SELECT * FROM STATION_DATA WHERE MONTH IN (3,6,9,12) #not in SELECT * FROM STATION_DATA WHERE MONTH NOT IN (3,6,9,12) #modulus operator #modulus returns the remainder instead of the quotient. A remainder of 0 means there is no remainder at all SELECT * FROM STATION_DATA WHERE MONTH % 3 = 0 #using where on text SELECT * FROM STATION_DATA WHERE report_code in (&#39;513A63&#39;, &#39;1F8A7B&#39;) SELECT * FROM STATION_DATA WHERE length(report_code) = 6 #wildcards SELECT * FROM STATION_DATA WHERE report_code LIKE &#39;A%&#39; #B as the first, C as the third letter SELECT * FROM STATION_DATA WHERE report_code LIKE &#39;B_C%&#39; #Other text functions as INSTR, SUBSTR, REPLACE ETC SELECT * FROM station_data WHERE snow_depth IS NULL; #Use coalesce to conert NULL to 0, &quot;N/A&quot; etc SELECT * FROM station_data WHERE coalesce(precipitation,0) &lt;= 0.5; SELECT * FROM station_data WHERE (rain = 1 AND temperature &lt;= 32) OR snow_depth &gt; 0; 4.1.2 GROUP BY WHERE filters individual records while HAVING filters aggregations. SELECT year, month, COUNT(*) AS record_count FROM station_data WHERE tornado = 1 GROUP BY year, month ORDER BY year, month #aggregate SELECT month, AVG(temperature) as avg_temp FROM station_data WHERE year &gt;= 2000 GROUP BY month #HAVING statement #To be able to filter on aggregate data you need to use HAVING instead of WHERE SELECT year, SUM(precipitation) as total_precipitation FROM station_data GROUP BY year HAVING sum(precipitation) &gt; 30 4.1.3 CASE statements CASE statements are read from top to bottom, so the first true condition is the one it uses. A great benefit of CASE statements compared to WHERE is that you can apply different filters for different aggregate values. SELECT report_code, year, month, day, wind_speed, CASE WHEN wind_speed &gt;= 40 THEN &#39;HIGH&#39; WHEN wind_speed &gt;= 30 THEN &#39;MODERATE&#39; ELSE &#39;LOW&#39; END as wind_severity FROM station_data # Use of CASE to apply different filters SELECT year, month, SUM(CASE WHEN tornado = 1 THEN precipitation ELSE 0 END) as tornado_precipitation, SUM(CASE WHEN tornado = 0 THEN precipitation ELSE 0 END) as non_tornado_precipitation FROM station_data GROUP BY year, month # Use of boolean expression SELECT month, AVG(CASE WHEN rain OR hail THEN temperature ELSE null END) AS avg_precipitation_temp, AVG(CASE WHEN NOT (rain OR hail) THEN temperature ELSE null END) AS avg_non_precipitation_temp FROM station_data WHERE year &gt; 2000 GROUP BY month 4.1.4 JOIN In multiple joins, it may be erroundous to mix LEFT JOIN with INNER JOIN. This is becasue null values cannot be inner joined on and will get filtered out. LEFT JOIN tolerates null values. #INNER JOIN SELECT ORDER_ID, CUSTOMER.CUSTOMER_ID, ORDER_DATE, ORDER_QTY FROM CUSTOMER INNER JOIN CUSTOMER_ORDER ON CUSTOMER.CUSTOMER_ID = CUSTOMER_ORDER.CUSTOMER_ID #LEFT JOIN SELECT ORDER_ID, CUSTOMER.CUSTOMER_ID, ORDER_DATE, ORDER_QTY FROM CUSTOMER LEFT JOIN CUSTOMER_ORDER ON CUSTOMER.CUSTOMER_ID = CUSTOMER_ORDER.CUSTOMER_ID #Checking for NULL values SELECT CUSTOMER.CUSTOMER_ID, NAME AS CUSTOMER_NAME FROM CUSTOMER LEFT JOIN CUSTOMER_ORDER ON CUSTOMER.CUSTOMER_ID = CUSTOMER_ORDER.CUSTOMER_ID WHERE ORDER_ID IS NULL #Multiple joins SELECT ORDER_ID, CUSTOMER.CUSTOMER_ID, &#39;NAME AS CUSTOMER.NAME,&#39; STREET_ADDRESS, CITY, STATE, ZIP, ORDER_DATE, PRODUCT_ID, DESCRIPTION, ORDER_QTY FROM CUSTOMER INNER JOIN CUSTOMER_ORDER ON CUSTOMER_ORDER.CUSTOMER_ID = CUSTOMER.CUSTOMER_ID INNER JOIN PRODUCT ON CUSTOMER_ORDER.PRODUCT_ID = PRODUCT.PRODUCT_ID #Use coalesce() to turn nulls into zeros. SELECT CUSTOMER.CUSTOMER_ID, NAME AS CUSTOMER_NAME, coalesce(sum(ORDER_QTY * PRICE), 0) as TOTAL_REVENUE FROM CUSTOMER LEFT JOIN CUSTOMER_ORDER ON CUSTOMER.CUSTOMER_ID = CUSTOMER_ORDER.CUSTOMER_ID LEFT JOIN PRODUCT ON CUSTOMER_ORDER.PRODUCT_ID = PRODUCT.PRODUCT_ID GROUP BY 1,2 4.2 SQL databases and R 4.2.1 Connecting to a database from R Access a database from R. The problem with dplyr is that all operations are conducted in-memory and thus the amount of data you can work with is limited by available memory. The database connection essentially removes that limitation. Accessing a temp database by downloading it. Dplyr and dbplyr are used in R to point to the database. #https://datacarpentry.org/R-ecology-lesson/05-r-and-databases.html library(&quot;RSQLite&quot;) library(&quot;plyr&quot;) library(&quot;dbplyr&quot;) # Downloading database for test dir.create(&quot;data_raw&quot;, showWarnings = FALSE) download.file(url = &quot;https://ndownloader.figshare.com/files/2292171&quot;, destfile = &quot;data_raw/portal_mammals.sqlite&quot;, mode = &quot;wb&quot;) # Connect to databse mammals &lt;- DBI::dbConnect(RSQLite::SQLite(), &quot;data_raw/portal_mammals.sqlite&quot;) # Querying with SQL-syntax vs dplyr syntax #sql tbl(mammals, sql(&quot;SELECT year, species_id, plot_id FROM surveys&quot;)) #dplyr surveys &lt;- tbl(mammals, &quot;surveys&quot;) surveys %&gt;% select(year, species_id, plot_id) #Checking head(surveys, n = 10) and nrow(surveys) we see that the surveys at first glance looks like a data frame but there are some differences.* head(surveys, n = 10) nrow(surveys) #The reason for this is that dplyr dosen´t see the full dataset, only what was asked for when the question in dplyr was translated into SQL. 4.2.2 Running SQL syntax in R library(sqldf) #https://dept.stat.lsa.umich.edu/~jerrick/courses/stat701/notes/sql.html#introduction sqldf(&#39;SELECT age, circumference FROM Orange WHERE Tree = 1 ORDER BY circumference ASC&#39;) sqldf(&quot;SELECT * FROM iris&quot;) #example data(BOD) BOD #Wildcard: used to extract everything bod2 &lt;- sqldf(&#39;SELECT * FROM BOD&#39;) bod2 #LIMIT controls the number of results sqldf(&#39;SELECT * FROM iris LIMIT 5&#39;) #ORDER BY syntax: ORDER BY var1 {ASC/DESC}, var2 {ASC/DESC} sqldf(&quot;SELECT * FROM Orange ORDER BY age ASC, circumference DESC LIMIT 5&quot;) #Where can be used to add conditional statements sqldf(&#39;SELECT demand FROM BOD WHERE Time &lt; 3&#39;) #WHERE with AND and OR sqldf(&#39;SELECT * FROM rock WHERE (peri &gt; 5000 AND shape &lt; .05) OR perm &gt; 1000&#39;) #IN is used to similiar to %in% sqldf(&#39;SELECT * FROM BOD WHERE Time IN (1,7)&#39;) sqldf(&#39;SELECT * FROM BOD WHERE Time NOT IN (1,7)&#39;) #LIKE weak expression command sqldf(&#39;SELECT * FROM chickwts WHERE feed LIKE &quot;%bean&quot; LIMIT 5&#39;) sqldf(&#39;SELECT * FROM chickwts WHERE feed NOT LIKE &quot;%bean&quot; LIMIT 5&#39;) #Aggregated data: AVG, MEDIAN, MAX, MIN, SUM sqldf(&quot;SELECT AVG(circumference) FROM Orange&quot;) #SELECT COUNT d &lt;- data.frame(a = c(1,1,1), b = c(1,NA,NA)) d sqldf(&quot;SELECT COUNT() as numrows FROM d&quot;) sqldf(&quot;SELECT COUNT(b) FROM d&quot;) "]
]
